<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<title>화면 부수기</title>
		<meta name="viewport" content="width=device-width,user-scalable=no" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<script type="text/javascript" src="/libs/three.js"></script>
		<script type="text/javascript" src="/libs/stats.js"></script>
		<script type="text/javascript" src="/libs/dat.gui.js"></script>

		<script type="text/javascript" src="/assets/fonts/helvetiker_regular.typeface.js"></script>
		<script type="text/javascript" src="/assets/fonts/helvetiker_bold.typeface.js"></script>
		<script
			type="text/javascript"
			src="/assets/fonts/bitstream_vera_sans_mono_roman.typeface.js"
		></script>

		<style>
			body {
				/* set margin to 0 and overflow to hidden, to
             use the complete page */
				margin: 0;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		{% block content %} {% endblock %}
		<!-- 프레임 확인-->
		<div id="Stats-output"></div>

		<!-- Div which will hold the Output -->
		<div id="WebGL-output"></div>

		<!-- Javascript code that runs our Three.js examples -->
		<script type="text/javascript">
			const camera = new THREE.PerspectiveCamera(
				45,
				window.innerWidth / window.innerHeight,
				0.1,
				1000
			);
			const scene = new THREE.Scene();
			const renderer = new THREE.WebGLRenderer();

			// once everything is loaded, we run our Three.js stuff.
			function init() {
				const stats = initStats();

				renderer.setClearColor(new THREE.Color(0xeeeeee, 1.0));
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.shadowMapEnabled = true;

				// add the sphere to the scene

				// position and point the camera to the center of the scene
				camera.position.x = -200;
				camera.position.y = 200;
				camera.position.z = 200;
				camera.lookAt(new THREE.Vector3(0, 0, 0));

				const dirLight = new THREE.DirectionalLight();
				dirLight.position.set(100, 100, 100);
				scene.add(dirLight);

				const dirLight2 = new THREE.DirectionalLight();
				dirLight2.position.set(-100, 100, 100);
				scene.add(dirLight2);

				// add the output of the renderer to the html element
				document.getElementById('WebGL-output').appendChild(renderer.domElement);

				// call the render function
				let step = 0;

				let text1, text2;

				var controls = new (function () {
					this.size = 30;
					this.height = 15;
					this.bevelThickness = 2;
					this.bevelSize = 0.5;
					this.bevelEnabled = true;
					this.bevelSegments = 3;
					this.bevelEnabled = true;
					this.curveSegments = 12;
					this.steps = 1;
					this.font = 'helvetiker';
					this.weight = 'normal';
					/*
            this.rotationSpeed = 0.02;
            this.bouncingSpeed = 0.03;
			*/
					this.asGeom = function () {
						// remove the old plane
						scene.remove(text1);
						scene.remove(text2);
						var options = {
							size: controls.size,
							height: controls.height,
							weight: controls.weight,
							font: controls.font,
							bevelThickness: controls.bevelThickness,
							bevelSize: controls.bevelSize,
							bevelSegments: controls.bevelSegments,
							bevelEnabled: controls.bevelEnabled,
							curveSegments: controls.curveSegments,
							steps: controls.steps,
						};

						text1 = createMesh(new THREE.TextGeometry('breaking', options));
						text1.position.x = -50;
						text1.position.y = 0;
						text1.position.z = -40;

						scene.add(text1);
						text2 = createMesh(new THREE.TextGeometry('Screen-3D', options));
						text2.position.x = -50;
						text2.position.y = -35;
						text2.position.z = -35;

						scene.add(text2);
					};
				})();

				controls.asGeom();
				const gui = new dat.GUI();
				/*
        gui.add(controls, 'rotationSpeed', 0, 0.5);
        gui.add(controls, 'bouncingSpeed', 0, 0.5);
		*/

				render();
				function createMesh(geom) {
					// assign two materials
					//            var meshMaterial = new THREE.MeshLambertMaterial({color: 0xff5555});
					//            var meshMaterial = new THREE.MeshNormalMaterial();
					var meshMaterial = new THREE.MeshPhongMaterial({
						specular: 0xffffff,
						color: 0xeeffff,
						shininess: 100,
						metal: true,
					});
					//            meshMaterial.side=THREE.DoubleSide;
					// create a multimaterial
					var plane = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial]);

					return plane;
				}
				function render() {
					stats.update();
					// rotate the cube around its axes

					// render using requestAnimationFrame
					requestAnimationFrame(render);
					renderer.render(scene, camera);
				}

				function initStats() {
					const stats = new Stats();

					stats.setMode(0); // 0: fps, 1: ms

					// Align top-left
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.left = '0px';
					stats.domElement.style.top = '0px';

					document.getElementById('Stats-output').appendChild(stats.domElement);

					return stats;
				}
			}
			function onResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			window.onload = init;

			// listen to the resize events
			window.addEventListener('resize', onResize, false);
		</script>
	</body>
</html>